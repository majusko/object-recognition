\documentclass[12pt]{article}

\usepackage[slovak]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
%%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{bmpsize}
\usepackage{pdfpages}
\usepackage{wrapfig}
\usepackage{setspace}
\usepackage{esvect}
\usepackage{listings}
\usepackage{color}
\usepackage[top=2.54cm, bottom=2.54cm, left=3.5cm, right=2.0cm]{geometry}

\setstretch{1.5}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keywordstyle=\color{blue},       % keyword style
  language=Octave,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\begin{document}

\title{Rozpoznávanie dopravných značiek}

\author{Mário Kapusta}
%% titulka s informaciami
\maketitle
\thispagestyle{empty}
\clearpage
%% obsah
\tableofcontents
\addtocontents{toc}{\protect\thispagestyle{empty}}
\thispagestyle{empty}
\clearpage
%%zoznam tauliek
\listoftables
\thispagestyle{empty}
\clearpage
%%zoznam orazkov
\listoffigures
\thispagestyle{empty}
\clearpage
%% astrakt
\begin{abstract}
Cieľom bakalárskej práce je podrobne informovať čitateľa s problematikou rozpoznávania dopravného značenia.
Predstaviť vývoj a aktuálny stav v tejto oblasti a dôkladne oboznámiť s momentálne najlepšou technológiou rozpoznávania objektov pomocou počítačového videnia.
V práci je predstavený návrh a taktiež implementácia technológie podľa existujúceho algoritmu rozpoznávania dopravného značenia, upravený pre naše potreby.
Súčasťou je plne funkčná Android aplikácia, ktorá dokáže vyhľadať príkazové a zákazové dopravné značenia. Funkčnosť a úspešnosť hľadania aplikácie bola otestovaná a zdokumentovaná.
\\\\
\textbf{Kľúčové slová:} dopravné značky, počítačové videnie, rozpoznávanie objektov, detekcia, Android, OpenCV
\end{abstract}
\clearpage

\centerline{\textbf{Abstract}}
\paragraph{}
Cieľom bakalárskej práce je podrobne informovať čitateľa s problematikou rozpoznávania dopravného značenia.
Predstaviť vývoj a aktuálny stav v tejto oblasti a dôkladne oboznámiť s momentálne najlepšou technológiou rozpoznávania objektov pomocou počítačového videnia.
V práci je predstavený návrh a taktiež implementácia technológie podľa existujúceho algoritmu rozpoznávania dopravného značenia, upravený pre naše potreby.
Súčasťou je plne funkčná Android aplikácia, ktorá dokáže vyhľadať príkazové a zákazové dopravné značenia. Funkčnosť a úspešnosť hľadania aplikácie bola otestovaná a zdokumentovaná.
\\\\
\textbf{Kľúčové slová:} traffic signes, computer vision, object recognition, detection, Android, OpenCV
\clearpage

\section*{Úvod}
\clearpage
\section{Rozpoznávanie objektov}
\paragraph{}
Rozpoznávanie objektov v počítačovom videní sa zaoberá problematikou rozpoznania už bežne známych objektov v reálnom svete, pomocou technológií.
Táto úloha je prekvapivo ťažká. Ľudia vedia rozpoznávať objekty reálneho sveta bez námahy a okamžite. Problém nastáva však pri algoritmickom opise tejto úlohy, ktorej by chápali stroje.
\cite{machine_vission}
\paragraph{}
Okrem zložitého algoritmického problému, tu existuje aj skutočnosť, že pre kvalitné rozpoznanie akéhokoľvek objektu sme taktiež závislí na hardware.
Keďže rozpoznávame z obrazu, tento obraz je potrebné zachytávať kamerou. Čím lepšie vie kamera pracovať so svetlom a má kvalitnejšie parametre, tým je väčšia šanca že rozpoznanie objektu bude kvalitnejšie.
Pri rozpoznávaní objektov je veľmi dôležité aj umiestnenie kamery. Tam platí, čím kolmejšie k objektu je kamera smerovaná, tým je objekt viac viditeľný a tak aj ľahšie rozpoznateľný. 
\cite{machine_vission}
\paragraph{}
Problematika rozpoznávania objektov sa ďaľej delí na konkrétnejšie problémy. V našom prípade sa jedná o problematiku rozpoznávania dopravných značení.
\cite{machine_vission}
\subsection{Spôsoby detekcie naučených vzorov v obraze}
\paragraph{}
Existuje mnoho spôsobov, akými môžeme rozpoznávať objekty v obraze.
\begin{enumerate}
  \item \textbf{Metódy založené na vzhľade} - Rozpoznávanie objektov pri týchto je postavené na princípe podobnosti vzhľadu.
  Pri tomto princípe si všímame celý objekt. Problémy pri tomto druhu rozpoznávania je nepríklad pri zmene svetelnosti, alebo uhlu. Medzi najpoužívanejšie patria aj nasledujúce metódy.
	\cite{computer_vission_aaa}
	\begin{itemize}
	  \item \textbf{Porovnávanie hrán} - Metóda porovnávania hrán sa môže vykonávať napríklad cez algoritmus ktorý navrhol profesor Canny.
	  Výhoda pri tejto metóde je tá, že svetelnosť zvyčajne nemá vplyv na výsledky. Postup je nasledovný: 
	  Nájdu sa hrany v našom vzore a našom obraze, následne sa tieto dva výsledky porovnajú a nakoniec sa vyhodnotí tolerancia ktorú akceptujeme.
	  \item \textbf{Metóda rozdeľ a panuj} - Táto metóda vyhľadávania je jedna z najúspešnejších. Zaručene nájdete všetky zhody ktoré spĺňajú kritérium, ktoré si určíte ne začiatku.
	  \item \textbf{Porovnávanie podľa odtieňu šedej} - Táto metóda jednoducho porovnáva odtien šedi v obraze. Je veľmi citlivá na svetelné zmeny.
	\end{itemize}
  \item \textbf{Metódy založené na znakoch v obraze} - Metódy sú postavené na konkrétnych znakoch v obraze, ktoré spĺňajú podmienky.
  	\begin{itemize}
  	  \item \textbf{Interpretačné stromy} - Zoraďuje jedotlivé zhody a potom nimi prehľadáva pomocou stromových technýk. Málo používaná metóda.
  	  \item \textbf{Pozičná konzistencia} - Porovnáva jednotlivé znaky v obraze podľa pozícií v ktorých sa nachádzajú medzi sebou.
  	  \item \textbf{Geometrická konzistencia} - Zisťuje zodpovedajúce geomtrické znaky v obraze. Túto metódu v podstate využívame pri vyhľadávaní dopravného značenia.
  	\end{itemize}
\end{enumerate}
\paragraph{}
V našej téme sa zaoberáme rozpoznávaním dopravných značení. Aj pri tomto type rozpoznávania sa môžeme venovať rôznym oblastiam detekcie naučených vzorov, no my sme si vybrali cestu rozpoznávania podľa farby a tvaru.
V podstate sa však stále jedná o metódu porovnávania hrán. V našom prípade budeme musieť nájsť hrany farieb a zistiť či dané hrany sú pre nás geometrickým tvarom akceptovateľné, alebo nie.
Táto metóda je podľa literatúry veľmi obľúbená pri rozpoznavaní nie len dopravných značení, ale aj iných objektov.
\cite{computer_vission_aaa}
\subsection{Neurónové siete}
\paragraph{}
\subsection{Rozpoznávanie dopravných značení}
\paragraph{}
Problematika rozpoznávania dopravných značení je pomerne nová a pri písaní práce som tak mohol čerpať len z veľmi malého počtu literatúry, zaoberajúcou sa touto témou.
Bol som donútený študovať prolematiku podrobne a vytvoriť riešenie, hlavne na poznatkoch z rozpoznávania iných objektov.
Popri tvorbe práce, vznikali rôzne ďaľšie práce a publikácie zaoberajúce sa konkrétne témou rozpoznávania dopravných značení.
Nebolo však možné sledovať všetky nové objavy a zistenia v tejto oblasti, ktoré vznikali popri tvorbe tejto bakalárksej práci.
Rozbor témy rozpoznávania dopravných značení je tak postavený hlavne na informáciách z jesene 2012.
\paragraph{}
Výskum témy rozpoznávania dopravných značení má v praxi silné uplatnenie. V oblasti dopravy, by to znamenalo pomoc vodičom vnímať a rozpoznávať, dopravné značenia, ktoré si vodič nevšimol, nepochopil poprípade im nerozumie.
Napriek tomu, že máme k dispozícii už dlhý výskum v oblasti počítačového videnia a množstvo kvalitného hardwaru, je úloha rozpoznávania dopravných značení pomerne zložitá.
Skutočnosť, že systém musí reagovať pomerne rýchlo na dynamické zmeny ktoré pri jazde autom nastávajú a taktiež s rôznorodým pozadím a viditeľnosťou, ktoré nám prostredie vytvára,
nám vytvára komplexnú problematiku v počítačovom videní, ktorej sa oplatí venovať pozornosť.\cite{tfs_pdf}
\paragraph{}
Konkrétne, problematika rozpoznávania dopravných značiek obsahuje dve fázy, z ktorých sa celý proces skladá:
\begin{enumerate}
  \item \textbf{Detekcia dopravného značenia} - detekuje umiestnenie dopravného značenia v obraze.
  \item \textbf{Rozpoznanie detekovaného dopravného značenia} - rozpoznáva významovú hodnotu dopravného značenia.
\end{enumerate} 
Existuje viac techník pre detekciu dopravných značení, ale ako najúčinnejšia metóda sa ukázalá farebná segmentácia a následné rozpoznanie podľa tvaru.
Pri získavaní významovej hodnoty značky je najefektívnejšie využiť neurónové siete.
\cite{tfs_pdf}
\paragraph{}
Prvý rozpoznávač dopravných značení bol do praxe nasadený v roku 2008, spoločnosťou BMW.\cite{bmw} Nasledujúci rok nasadila svoj prvý systém pre rozpoznávanie dopravných značení aj spoločnosť Mercedes.\cite{mercedes}
Tieto prvé rozpoznávače dopravných značení vedeli rozpoznávať len značky ktoré hovorili o rýchlostnom obmedzení. Hneď na to boli tieto automobilky nasledované ďalšími konkurentami, ktorí systém rozpoznávania vylepšovali o rôzne funkcionality.
Od roku 2012 vyvýja firma Volvo komplexný systém rozpoznávania dopravných značení pomocou počítačového videnia, ktorý nazvala Road Sign Information. Tento systém je implementovaný vo všetkých nových modeloch spomínanej automobilky.\cite{volvo}
%%nieco odbornejsie este
\subsection{Rozpoznávanie iných objektov}
Rozpoznávanie jednotlivých objektov v obraze spočíva v tom, objaviť potrebné obrazové regióny hľadaného modelu, pričom sa snažiť ignorovať pozadie.
Tieto regióny sú však pre každý objekt iné. Niekedy je potrebné sledovať farbu, inokedy tvary alebo pohyb. Pri niektorých špecifických objektoch je potrebné hľadať rôzne body a počítať uhly, ktoré zvierajú.
Medzi tieto špecifickejšie objekty patrí napríklad problematika rozpoznávania tvárí.
\cite{object_rec_scene}
\subsubsection{Rozpoznávanie tvárí}
Proces rozpoznávania tvárí je postavený na takom princípe, že sa snažíme hľadať už známe kontrasty medzi regiónmy na tváry a ich priestorových vzťahov ktoré vyjadrujú.
Tieto vzťahy nie sú také jednoznačné a tak sa museli vypracovať algoritmy, a spôsoby ktoré problematiku riešia. 
Najpoužívanejšia metóda je používať neurónovú sieť, ktorej posielame vzorky správnych a nesprávnych vzťahov a naučíme stroj rozpoznávať tváre sám.
V súčasnosti už nie je problém nájsť takúto technológiu použítú kdekoľvek vo svete.
\cite{object_detection_viola}
\section{Výskum}
\paragraph{}
Cieľom práce je vypracovať komplexný návrh riešenia pre vyhľadávanie a rozpoznávanie dopravného značenia a taktiež vytvoriť funkčnú aplikáciu, ktorá
bude schopná rozpoznať zvislé dopravné značenia. Táto aplikácia bude naprogramovaná v jazyku Java a bude spustiteľná na
 operačnom systéme Android 2.3, ktorý je určený pre mobilné zariadenia. Computer vision (počítačové videnie), nám zaručí open-source knižnica OpenCV.
\subsection{Matematické metódy}
\paragraph{}
Mnoho matematických metód sa bude priamo vysvetlovať pri predstavovaní danej OpenCV funkcionality.
V tejto sekcii si predstavíme také matematické metódy ktoré nám pomůžu lepšie sa orientovať pri opise konkrétnych funkcionalít OpenCV.
\subsubsection{Konvolúcia}
\paragraph{}
Konvolúcia je matematická metóda, ktorá systematicky prechádza celý obraz a na výpočet novej hodnoty bodu využíva malé okolie \emph{O} reprezentatívneho bodu. 
Táto hodnota je zapísaná do nového obrazu. Diskrétna konvolúcia má tvar:
\begin{align*}
g(x,y) = \sum_{(m,n)} \sum_{(e^0)} h(x - m,y - n)f(m,n)
\end{align*}
kde f predstavuje obrazovú funkciu pôvodného obrazu, g predstavuje obrazovú funkciu nového obrazu, h predstavuje konvolučnú masku alebo konvolučné jadro, h nám udáva koeficienty jednotlivých bodov v okolí O.
Najčastejšie sa používajú  obdĺžníkové masky s nepárnym počtom riadkov a stĺpcov, pretože v tom prípade môže reprezentatívny bod ležať v strede masky.
\paragraph{}
Transformácie v lokálnom okolí bodu sa delia na dve skupiny: \\
\textbf{Vyhladzovanie} – tieto metódy sa snažia potlačiť šum v obraze, ale rozostrujú hrany. \\
\textbf{Ostrenie} – detekcia hrán a čiar, ale zosilňuje šum. \\
\paragraph{}
Podľa matematických vlastností môžeme metódy predspracovania rozdeliť na \\
\textbf{Lineárne metódy} – novú jasovú hodnotu bodu počítajú ako lineárnu kombináciu vstupných bodov. Napr.: priemerovací filter \\
\textbf{Nelineárne metódy} – berú do úvahy len body s určitými vlastnosťami. Napr.: mediánový filter.
\cite{DIP}
\subsubsection{Aproximácia}
\paragraph{}
Aproximácia je matematická metóda pri ktorej sa snažíme vyjadriť zložitú funkciu jednoducho. Túto metódu sa snažíme uskutočniť aritmetickými operáciami, ktoré dokze uskutočniť počítač.
Jednou z najlepšou metódou vyjadrenia funkcie jednoduchšie je cez polynómy, čo sú vlastne najjednoduchšie funkcie, ktoré možno na počítači vypočítať priamo. Taktiež sa dajú ľahko integrovať a derivovať a vo všeobecnosti sa s nimi jednoducho zaobchádza.
Každá aproximácia je presná na určitom intervale, mimo intervalu sú funkcie odlišné.
\cite{aproximacia}
\paragraph{}
Predstavme si, že našou úlohou je opísať rozloženie pôdneho znečistenia istou chemikáliou. K dispozícii máme samozrejme meracie prístroje. Jednotlivými vrtmi odoberáme vzorky pôdy, ktoré potom podrobíme analýze.
Prolém spočíva v tom, že nie je možné, aby sme takto zmapovali celú oblesť dokonale, keďze sme časovo aj finančne obmedzení. Takže našou úlohou bude dostať dostatočne presný opis znečistenia celého územia z konečného počtu meráni.
Musíme tak nejakým spôsobom preniesť namerané hodnoty na celú oblasť. O toto sa nám stará aproximácia. Existuje mnoho spôsobov ako tento prenos uskutočniť. Voľba metódy závisí od konkrétnej situácie.
\cite{num_metody}
\paragraph{}
Existuje niekoľko delení aproximácie, predstavíme si niekoľko základných typov a delení. Výber danej metódy závisí od konkrétneho problému.
\begin{enumerate}
  \item Rozdelenie aproximácií podľa aproximačnej funkcie
	\begin{itemize}
	  \item \textbf{Lineárny typ}
		\begin{align*}
		f(x) \approx a_0 g_0(x) + a_1 g_1(x) + \ldots + a_m g_m(x)
		\end{align*}
	  \item \textbf{Racionálny typ}
	  	\begin{align*}
		f(x) \approx \frac{a_0 g_0(x) + a_1 g_1(x) + \ldots + a_m g_m(x)}{b_0 g_0(x) + b_1 g_1(x) + \ldots + b_m g_m(x)}
		\end{align*}
	\end{itemize}
  \item Rozdelenie aproximácií podľa zvolených konštánt
  	\begin{itemize}
	  \item 
	  	\textbf{Interpolačná aproximácia} - Pri interpolácii si vyberieme nejaké body na vzore, čo je vlastne zložitá funkcia, z ktorej chceme dostať jednoduchšiu, napríklad obraz.
	  	Obraz musí tými bodmi na vzore prechádzať. Funkcie musia mať rovnakú deriváciu v danom bode.
	  \item 
	  	\textbf{Aproximácia metódou najmenších štvorcov} - Funkcia \emph{f(x)} a jej aproximácia majú pri tomto type aproximácie podobný obsah pod krivkou.
	  \item 
	  	\textbf{Čerbyševova aproximácia} - Tento typ aproximácie sa snaží o najmenší rozdiel medzi funkciou \emph{f(x)} a jej aproximáciou v určitom intervale.
	\end{itemize}
\end{enumerate}
V našej práci budeme využívať aproximáciu nepriamo. Väčšinou pôjde o aproximáciu pomocou bodov a teda interpoláciu.
\cite{aproximacia}
\subsubsection{Greenová veta}
\paragraph{}
Greenová veta bude použitá v práci opäť nepriamo. Bude ju používať OpenCV knižnica napríklad na výpočet veľkosti ľubovolnej kontúry. Greenová veta nám umožnuje previesť výpočet krivkového integrálu druhého druhu po jednoduchej uzavretej krivke na výpočet dvojného integrálu.
\cite{mat_an_2}	\\ \\
	  	\textbf{Formulácia} - \emph{Nech \begin{math}D \subset R^2 \end{math} je regulárna uzavrená oblasť, \begin{math}\partial \vv{D} \end{math} kladne orientovaná hranica oblasti D. Nech \begin{math} F = (F_1,F_2) \end{math} je vektorové  pole triedy \begin{math} c^1 \end{math} v D. Potom platí:}
	  	\begin{align*}
		\int_{\partial \vv{D}} F d\vv{s} = \int\int_{D} \text{rot} F d \mu \text{,}
		\end{align*}
		\emph{kde \begin{math} \mu \end{math} značí Jordanovú mieru. V zložkovom tvare.} 
		\begin{align*}
		\int_{\partial \vv{D}} F_1 d x + F_2 d y = \int\int_{D} \left ( \frac{\partial f_2}{\partial x} - \frac{\partial f_1}{\partial y} \right ) dxdy \text{. \cite{mat_an_2}}
		\end{align*}
\subsection{Funkcionalita OpenCV}
\paragraph{}
OpenCV je open source knižnica počítačového videnia. Knižnica je napísaná v programovacích jazykoch C a C++. Aktívne sa pracuje na
rozhraniach pre Python, Ruby, Matlab, Javu a iných programovacích jazykoch. V našej práci sme sa sústredili na verziu pre programovací jazyk Java,
ktorý sa používa pri tvore aplikácii pre Android OS.
\cite{learning_opencv}
\paragraph{}
OpenCV knižnica bola navrhnutá tak, aby funkcie použité v tejto knižnici, boli čo najefektívnejšie a čo najviac zamerané na real-time aplikácie.
Knižnica je napísaná v optimalizovanom jazyku C a tak môže jednoducho využiť aj silu viacjadrových procesorov.
Taktiež existujú knižnice, špeciálne určené pre procesory s architektúrou Intel. IPP (Integrated Performance Primitives) knižnice  sa skladajú z nízko levelových 
optimalizovaných postupov a rôznych algoritmických olastí, ktoré pracujú na procesoroch s architektúrou Intel oveľa efektívnejšie.
\cite{learning_opencv}
\paragraph{}
Jeden z hlavných cieľov OpenCV je sprístupniť jednoducho použiteľné prostredie ktoré pomôže developerom ľahko a rýchlo budovať aplikácie s použitím počítačového videnia
pre rôzne použitia v oblasti, medicíny, bezpečnosti, robotiky, dopravy, priemyselnej výroby a iných, pre ktoré ma OpenCV dokonca aj špecifické funkcionality.
\cite{learning_opencv}
\paragraph{}
Pre olasť rozpoznávania ojektov sú taktiež mnohé špecifické funkcionality.
Pri problematike rozpoznávania zvislích dopravných značení sme niektoré z nich použili a preto je potrebné si pre lepšie pochopenie problematiky tieto funkcie vysveliť podrobnejšie.
\subsubsection{cvtColor}
\paragraph{}
Funkcia \emph{cvtColor} prevedie obraz z jedného farebného spektra do iného. Je to jedna z najpoužívanejších funkcií, keďže na rozpoznávanie objektov je potrené si obraz pripraviť
cez mnohé farebné filtre. Vstupné parametre je možné pozorovať pri tabuľke \ref{cvtColorPar}.
\cite{OpenCVDoc}
\begin{table}
	\centering
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
    Premenná & Dátový typ & Popis \\ \hline
    src & Mat & Vstup je 8-bitový, 16-bitový obraz alebo formát čísla s plávajúcou desatinou čiarkou. \\ \hline
    dst & Mat & Výstupný obraz s rovnakými parametrami ako na vstupe. \\ \hline
    code & int & Farebné spektrum ktoré do ktorého požadujeme obraz previesť. \\
    \hline
    \end{tabular}
  	\caption{Tabulka znázorňuje vstupy funkcie cvtColor}
  	\label{cvtColorPar}
\end{table}
\paragraph{}
Pri používaní funkcie \emph{cvtColor}, je potrebné si určiť o akú konverziu ide. OpenCV, už má k dispozícii predpripravené konštanty, ktoré konverziu lepšie vyjadrujú.
Matematický prepočet si OpenCV už spraví v jadre. Konverzií je v OpenCV naprogramovaných už mnoho, my si predstavíme matematický model konverzie,
ktorú v našom prípade rálne využijeme. Jedná sa o konverziu z BGR(pri OpenCV je poradie kanálov pre model RGB zoradený opačne) do farebného modelu HSV a späť.
\cite{OpenCVDoc}
\paragraph{} 
V prípade 8 a 16 bitového obrazu je potrené jednotlivé kanály R,G a B previesť do formátu s plávajúcou desatinou čiarkou a zmenšiť rozsah od 0 do 1.
\begin{align*}
BGR \leftrightarrow HSV
\end{align*}
\begin{align*}
V \leftarrow max(R,G,B)
\end{align*}
\begin{align*}
S \leftarrow \begin{cases} \frac{V - min(R,G,B)}{V}, & \text{ pokiaľ } V \neq 0 \\ 0, & \text{ pokiaľ } V = 0 \end{cases} \\
\end{align*}
\begin{align*}
H \leftarrow \begin{cases} \frac{60(G - B)}{V - min(R,G,B)}, & \text{ pokiaľ } V = R \\ \frac{120 + 60(B - R)}{V - min(R,G,B)}, & \text{ pokiaľ } V = G \\ \frac{240 + 60(R - G)}{V - min(R,G,B)}, & \text{ pokiaľ } V = B \end{cases} 
\end{align*}
\begin{align*}
\text{ Pokiaľ } H < 0, & \text{ tak } H = H + 360
\end{align*}
\begin{align*}
\text{ Na výstup pôjde } 0 \le V \le 1, 0 \le S \le 1, 0 \le H \le 1
\end{align*}
\subsubsection{Canny}
\paragraph{}
Hlavná úloha funkcie \emph{Canny} je vyhľadávať okraje, kontúry a hrany všetkých objektov. Pri kombinácii s rôznymi filtrami, môžeme docieliť, vyhľadanie hrán úmyselného objektu.
Na rozoznávanie sa využíva algoritmus \emph{Canny86}.
\cite{canny, OpenCVDoc}
\paragraph{}
Kontúrový alebo hranový detektor by mal spĺňať tri kritéria, ktoré určil John Canny.
\begin{enumerate}
  \item Detekčné kritérium, detektor nesmie zabudnúť na významnú hranu a na jednu hranu môže byť maximálne jedna odozva.
  \item Lokalizačné kritérium, rozdiel medzi skutočnou a nájdenou hranou má byť minimálny.
  \item Kritérium jednej odozvy.
\end{enumerate}
Cannyho detektor využíva konvolúciu s dvojrozmerným Gaussianom a deriváciu v smere gradientu.
Poskytuje informácie o smere a veľkosti hrany. Nech G je dvojrozmerný Gaussian. Nech Gn je prvá derivácia G v smere gradientu
\begin{align*}
G_n = \frac{\delta G}{\delta n} = n\bigtriangledown G
\end{align*}
kde n je smer gradientu, ktorý dostaneme nasledovne
\begin{align*}
n = \frac{\bigtriangledown(G * f)}{|\bigtriangledown(G * f)|}
\end{align*}
Hranu dostaneme v bode, kde funkcia \begin{math}\ G_n *f  \end{math} dosiahne lokálne maximum, a druhá derivácia sa rovná nule.
\begin{align*}
\frac{\delta^2}{\delta n^2} G * f = 0
\end{align*}
Pre silu hrany platí:
\begin{align*}
|G_n * f| = |\bigtriangledown (G * f)|
\end{align*}
Kritérium jednej odozvy sa dosahuje následne prahovaním. 
\cite{DIP, JCanny}
\paragraph{}
Vstupné parametre je možné pozorovať pri tabuľke \ref{cannyPar}.
Najmenšia hodnota medzi \emph{threshold1} a \emph{threshold2} je použitá na prepájanie kontúr. Tá najväčšia hodnota je použitá ako začínajúci segment najsilnejších kontúr.
Pri správnom nastavení, sa dá dosiahnuť pomerne kvalitné odstránenie nepotrených kontúr.
\cite{OpenCVDoc}
\begin{table}
	\centering
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
    Premenná & Dátový typ & Popis \\ \hline
    image & Mat & Vstup je 8-bitový obraz s jedným farebným kanálom. \\ \hline
    edges & Mat & Výstup je mapa všetkých nájdených kontúr. \\ \hline
    threshold1 & double & Prvá prahová hodnota (threshold). \\ \hline
    threshold2 & double & Druhá prahová hodnota (threshold). \\
    \hline
    \end{tabular}
  	\caption{Tabulka znázorňuje vstupy funkcie canny}
  	\label{cannyPar}
\end{table}
%%\subsubsection{HoughLinesP}
%%nebolo v praci pouzite
\subsubsection{GaussianBlur}
\paragraph{}
Vyhladzuje obraz pomocou \emph{GaussianBlur} filtra.
\cite{OpenCVDoc}
\paragraph{}
\emph{GaussianBlur} filter funguje na princípe \emph{N * N} konvolúcie pri ktorej sa každý pixel prehodnotí na základe \emph{Gaussian} funkcie.
Táto funkcia tak prevedie rozostrenie pre každý pixel obrazu.
\cite{gaussianblur}
\begin{align*}
H(x,y) = \frac{1}{2\pi\sigma^2}e^{\frac{(x^2)+(y^2)}{2\sigma^2}}
\end{align*}
\paragraph{}
Princíp konvolúcie 2D obrazu je postavený na tom, že sa systematicky snažíme spracovávať okolie pixelu a dostať výslednú hodnotu z okolia reprezentatívneho bodu.
Konvolúcia sa často používa pri spracovávaní obrazu, ako je vyhladzovanie obrazu, ostrenie, detekcia hrán a obrázkov.
\cite{convolution}
\cite{DIP}
\paragraph{}
Vstupné parametre pre \emph{GaussianBlur} je možné pozorovať pri tabuľke \ref{gaussianblurPar}. 
Pri premennej \emph{ksize} si môžeme napríklad nastaviť veľkosť matice, ktorá sa bude pri konvolúcii používať.
Veľkosť matice pri konvolúcii ovplivní rozostrenie. Čím väčšiu maticu používame, tím väčšie rozostrenie dostaneme.
\cite{OpenCVDoc}
\begin{table}
	\centering
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
    Premenná & Dátový typ & Popis \\ \hline
    src & Mat & Vstup je obraz s ľubovolným počtom farebných kanálov. \\ \hline
    dst & Mat & Výstup s rovnakými parametrami ako bol vstup. \\ \hline
    ksize & Size & Veľkosť Gaussian jadra. Matica konvolúcie. \\ \hline
    sigmaX & double & Smerodajná odchýlka Gaussian jadra v smere X. \\ \hline
    sigmaY & double & Smerodajná odchýlka Gaussian jadra v smere Y. \\
    \hline
    \end{tabular}
  	\caption{Tabulka znázorňuje vstupy funkcie GaussianBlur}
  	\label{gaussianblurPar}
\end{table}
\subsubsection{inRange}
\paragraph{}
Funkcia \emph{inRange} zisťuje, či sa prvky poľa nachádzajú medzi prvkami ďalších dvoch polí.
\paragraph{}
Funkcia kontroluje rozsah nasledujúco:
\begin{itemize}
  \item Pre každý prvok vstupného pola s jedným kanálom
	\begin{align*}
	dst(I) = lowerb(I)_0 \le src(I)_0 \le upperb(I)_0
	\end{align*}
  \item Pre každý prvok vstupného pola s dvomi kanálmy
  	\begin{align*}
	dst(I) = lowerb(I)_0 \le src(I)_0 \le upperb(I)_0 \wedge lowerb(I)_1 \le src(I)_1 \le upperb(I)_1
	\end{align*}
  \item A tak ďaľej\ldots
\end{itemize}
\paragraph{}
Vstupné parametre pre \emph{inRange} je možné pozorovať pri tabuľke \ref{inRangePar}. 
\cite{OpenCVDoc}
\begin{table}
	\centering
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
    Premenná & Dátový typ & Popis \\ \hline
    src & Mat & Vstupné zdrjové pole. \\ \hline
    lowerb & Scalar & Spodná hranica poľa alebo skalárna veličina. \\ \hline
    upperb & Scalar & Vrchná hranica poľa alebo skalárna veličina. \\ \hline
    dst & Mat & Výsledné pole, rovnako veľké ako vstup. \\
    \hline
    \end{tabular}
  	\caption{Tabulka znázorňuje vstupy funkcie inRange}
  	\label{inRangePar}
\end{table}
\subsubsection{bitwise\_not}
\paragraph{}
Je jednoduchá funkcia, ktorá invertuje všetky bity v poli ktoré jej pošlete. Taktiež má aj jednoduché vstupné parametre, ktoré vidieť aj v tauľke \ref{bitwisePar}.
\cite{OpenCVDoc}
\begin{table}
	\centering
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
    Premenná & Dátový typ & Popis \\ \hline
    src & Array & Vstupné pole plné bitov. \\ \hline
    dst & Array & Výstupné pole plné invetovaných bitov \\
    \hline
    \end{tabular}
  	\caption{Tabulka znázorňuje vstupy funkcie bitwise\_not}
  	\label{bitwisePar}
\end{table}
\subsubsection{threshold}
\paragraph{}
Aplikuje pevnú prahovú úrovní pre každý prvok poľa. Zvyčajne sa používa na získanie binárnej úrovne obrazu v odtieňoch sivej, alebo pre odstránenie šumu.
Funkcia \emph{treshold} funguje na princípe filtrovania pixelov ktoré majú príliž veľkú, alebo príliž malú hodnotu. Existuje niekoľko možností ako tento šum odstrániť.
\begin{itemize}
  \item THRESH\_BINARY
	\begin{align*}
	dst(x,y) = \begin{cases} maxval, & \text{ pokiaľ } src(x,y) > tresh \\ 0, & \text{ inak } \end{cases} \\
	\end{align*}
  \item THRESH\_BINARY\_INV
  	\begin{align*}
	dst(x,y) = \begin{cases} 0, & \text{ pokiaľ } src(x,y) > tresh \\ maxval, & \text{ inak } \end{cases} \\
	\end{align*}
  \item THRESH\_TRUNC
  	\begin{align*}
	dst(x,y) = \begin{cases} trashold, & \text{ pokiaľ } src(x,y) > tresh \\ src(x,y), & \text{ inak } \end{cases} \\
	\end{align*}
  \item THRESH\_TOZERO
  	\begin{align*}
	dst(x,y) = \begin{cases}  src(x,y), & \text{ pokiaľ } src(x,y) > tresh \\ 0, & \text{ inak } \end{cases} \\
	\end{align*}
  \item THRESH\_TOZERO\_INV
  	\begin{align*}
	dst(x,y) = \begin{cases} 0, & \text{ pokiaľ } src(x,y) > tresh \\  src(x,y), & \text{ inak } \end{cases} \\
	\end{align*}
\end{itemize}
Parametre ktoré táto funkcia akceptuje a s ktorými pracuje sú viditeľné v tauľke \ref{thresholdPar}
\cite{OpenCVDoc}
\begin{table}
	\centering
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
    Premenná & Dátový typ & Popis \\ \hline
    src & Mat & Vstupný 8-bitový obraz s jedným kanálom. \\ \hline
    dst & Mat & Výstupný 8-bitový obraz s jedným kanálom. \\ \hline
    thresh & double & Prahová hodnota \\ \hline
    maxval & double & Maximálna hodnota ktorú môže použiť na niektoré typy výpočtu. \\ \hline
    type & int & Typ výpočtu \\
    \hline
    \end{tabular}
  	\caption{Tabulka znázorňuje vstupy funkcie threshold}
  	\label{thresholdPar}
\end{table}
\subsubsection{findContours}
\paragraph{}
Funkcia \emph{findContours} je prepracovaná metóda hľadania obrysov. Jednoducho nájde obrysy, aleo kontúry v binárnom obraze pomocou algoritmu od Satoshi Suzukiho pre vyhľadávanie najkrajnejších čiar v binárnom obraze.
Vyhľadané obrysy sú veľmi užitočné pri rozpoznávaní tvarov a objektov. Pri rozpoznávaní dopravných značení je našou snahou taktiež rozpoznať napríklad kruhové tvary zákazových dopravných značení.
\cite{OpenCVDoc}
\paragraph{}
Algoritmus pre vyhľadanie najkrajnejších čiar je postavený na algoritme vyhľadávania čiar v v binárnom obraze. Popisuje sa v ňom 
\cite{suzuky}
\paragraph{}
Parametre funkcie vidiet v tabuľke \ref{findContoursPar}
\begin{table}
	\centering
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
    Premenná & Dátový typ & Popis \\ \hline
    image & Mat & Vstup je 8-bitový obraz ktorý má len jeden kanál, kde všetky hodnoty tohoto kanála ktoré sú väčšie ako 0, sa správajú ako keby mali hodnotu 1. \\ \hline
    contours & List:MatOfPoint & Výstup je zoznam kontúr. Každá kontúra je uložená ako vektor bodov. \\ \hline
    hierarchy & Mat & Voliteľný výstupný vektor obsahujúci informácie o typológii obrazu. Pre každú kontúru obsahuje množstvo elementov. \\ \hline
    mode & int & mód, aleo skôr typ kontúr ktoré budeme chcieť rozpoznávať. \\ \hline
    method & int & Metóda aproximácie. \\
    \hline
    \end{tabular}
  	\caption{Tabulka znázorňuje vstupy funkcie findContours}
  	\label{findContoursPar}
\end{table}
\subsubsection{boundingRect}
\paragraph{}
Funkcia \emph{boundingRect} je ďalšia jednoduchá funkcia. Dokáže jednoducho vypočítať a ohraničiť nejaké zoskupenie bodov do odĺžnika.
V našom prípade funkciu využijeme na to, aby sme vedeli získať výrez dopravného značenia. Vstup pre funkciu je len samotné zoskupenie bodov, ako vidieť aj na tabuľke \ref{boundingRectPar}.
\cite{OpenCVDoc}
\begin{table}
	\centering
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
    Premenná & Dátový typ & Popis \\ \hline
    points & MatOfPoint & Zoskupenie 2D bodov vo vektore. \\ 
    \hline
    \end{tabular}
  	\caption{Tabulka znázorňuje vstupy funkcie boundingRect}
  	\label{boundingRectPar}
\end{table}
\subsubsection{drawContours}
\paragraph{}
Funkcia \emph{drawContours} je vykreslovacia funkcia. Kreslenie kontúr pracuje s maticami. Dokáže vykresliť akýkoľvek tvar, ktorý je definovaný vektorom.
\cite{OpenCVDoc}
\paragraph{}
Funkcia je pomerne zložitá na parametre. Podrobnejšie je rozobratá v tabuľke \ref{drawcontoursPar}
\begin{table}
	\centering
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
    Premenná & Dátový typ & Popis \\ \hline
    image & Mat & Obraz do ktorého budú kontúry vkreslené. \\ \hline
    contours & List:MatOfPoint & Zoznam všetkých kontúr ktoré chceme vykresliť. Každá kontúra je uložená ako vektor bodov. \\ \hline
    contourIdx & int & Index, ktorý určuje ktorú kontúru chceme vykresliť. Negatívne číslo hovorí o tom, že chceme vykresliť všetky kontúry. \\ \hline
    color & Scalar & Farba vykreslenej kontúry. \\ \hline
    thickness & int & Šírka kontúry. \\ \hline
    lineType & int & Typ vykreslenej čiary. \\ \hline
    hierarchy & Mat & Voliteľný výstupný vektor obsahujúci informácie o typológii obrazu. Pre každú kontúru obsahuje množstvo elementov. \\ \hline
    maxLevel & int & Maximalný level vykreslených kontúr. Tento parameter je funkčný, len v prípade že je použitá hierarchia. \\ \hline
    offset & Point & Voliteľný parameter posunov. Posunie všetky kontúry podľa zadaných súradníc. \\
    \hline
    \end{tabular}
  	\caption{Tabulka znázorňuje vstupy funkcie drawcontours}
  	\label{drawcontoursPar}
\end{table}
\subsubsection{contourArea}
\paragraph{}
Jednoduchá funkcia, ktorá prepočítava veľkosť kontúry.
Túto veľkosť sa dá jednoducho využiť pri eliminácii malých kontúr, ktoré pri rozpoznávaní dopravného značenia nevyužijeme.
Pri výpočte je použitá Greenová veta. Funkcia nám vracia počet pixelov, ktoré kontúra obsahuje. Sú to pixely ktoré nemajú nulovú hodnotu.
Obsahuje len jeden parameter, ktorý je opísaný v tabuľke \ref{contourAreaPar}. Táto funkcia Často vráti zlé výsledky pre kontúry s vlastnými prepojeniami.
\cite{OpenCVDoc}
\begin{table}
	\centering
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
    Premenná & Dátový typ & Popis \\ \hline
    contour & Mat & Kontúra ktorú chceme prepočítať. \\ 
    \hline
    \end{tabular}
  	\caption{Tabulka znázorňuje vstupy funkcie contourArea}
  	\label{contourAreaPar}
\end{table}
\subsubsection{fitEllipse}
\paragraph{}
Funkcia \emph{fitEllipse} opäť patrí medzi ľahšie použiteľné funkcie. Jej hlavnou úlohou je vykresliť elipsu okolo skupiny 2D bodov.
Pri vykreslení sa snaží o to, aby bola vykreslená najmenšia možná elipsa pri čom využíva algoritmus Fitzgibbon95.
Parametre funkcie je vidieť v tabuľke \ref{fitEllipsePar}.
\paragraph{}
Obkec o Fitzgibbon95 algoritme.
%%Fitzgibbon95
\cite{OpenCVDoc}
\begin{table}
	\centering
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
    Premenná & Dátový typ & Popis \\ \hline
    points & MatOfPoint2f & Vektor 2D bodov okolo ktorých chceme elipsu vykresliť. \\ 
    \hline
    \end{tabular}
  	\caption{Tabulka znázorňuje vstupy funkcie fitEllipse}
  	\label{fitEllipsePar}
\end{table}
\section{Návrh riešenia}
\paragraph{}
Po dôkladnom naštudovaní literatúry a potrebných algoritmov je našim cieľom vyhotoviť riešenie, ktoré by dokázalo detekovať zvislé dopravné značenia.
Návrh bude pozostávať z návrhu algoritmov, návrhu objektov a návrhu užívateľského prostredia. Všetky algoritmy boli navrhnuté na základe práce \cite{tfs_pdf} z ktorej sme sa inšpirovali.
\subsection{Návrh algoritmov}
\paragraph{}
Ako metódu rozpoznávania som si zvolil detekciu dopravného značenia podľa tvaru a farby. 
Algoritmy ktoré som navrhol, sú postavené na princípe rozpoznania farebného rozhrania hľadaného objektu a následné detekovanie potrebného tvaru.
Pri opise som sa zameral na detekciu značiek, ktoré sú na cestách najviac početné.
Na cestách prevládajú dopravné značenia, ktoré sú červenej a modrej farby. Z tvarov prevládajú kruhy a trojuholníky.
Samotné rozpoznanie bolo uskutočnené pomocou neurónových sietí. Táto metóda je najlepšia na počítačové učenie objektov.
Na rozdiel od detekcie dopravného značenia, pre riešenie neurónových sietí použijeme už existujúcu knižnicu.
\subsubsection{Návrh algoritmu pre detekciu farby}
\paragraph{}
Ako prvý algoritmus som si vybral detekciu červenej farby. Pre detekciu farieb sa v literatúre odporúča najprv previesť vstup na farebný model HSV. 
Vstup prichádza vo farebnom formáte RGB. Farebný model HSV je jeden z dvoch najpoužívanejších valcovo súradnicových reprezentácii bodov pre RGB model.
\cite{hsl_hsv}
\begin{figure}[p]
\centering
\includegraphics[width=0.3\textwidth,natwidth=160,natheight=586]{hladanie_farby.jpg}
\vspace{-20pt}
\caption{Algoritmus vyhľadávania farby v obraze}
\vspace{-10pt}
\label{hladanie_farby}
\end{figure}
\paragraph{}
Na začiatok by sa mal vstup(bitmapa) konvertovať na binárnu maticu.
\paragraph{}
Najväčšia výhoda dopravného značenia je, že je silne kontrastné od ostatného prostredia.
Túto vlastnosť môžeme perfektne využiť v náš prospech a pomocou pomocou rozmazania obrazu, môžeme dosieliť to,
že sa zbavíme slabších kontú hneď na začiatku. V OpenCV je pre rozmazávanie obrazu na výber viacero metód,
no my použijeme matódu \emph{GaussianBlur}, ktorá už názvom prezrádza použitie známeho filtra \emph{Gaussian blur}
\paragraph{}
Keďže sa snažíme dostať náš vstupný obraz do formátu HSV, o ktorú sa stará funkcionalita \emph{cvtColor} 
potrebujeme mu nastaviť vstup tak, aby obraz vedel bez problémov spracovať. 
Keďže na väčšine mobilných zariadení prichádza do zariadenia obraz vo formáte RGBA, ďalší krok bude nepríklad konvertovanie formátu RGBA na formát RGB.
\paragraph{}
Ďalej bude nasledovať samotná konverzia obrazu do HSV pomocou už spomínanej metódy \emph{cvtColor}.
\paragraph{}
Ďalší krok bude spracovať každý kanál farebného modelu HSV samostatne. Ako prvý spracujeme \emph{Hue} kanál, ktorý sa stará o farebný odtien každého pixelu.
\emph{Hue} Farba sa v tomto kanáli určuje podľa stupňov. 
Primárne sa začína na stupni 0$^\circ$, čo predstavuje zelenú farbu, postupne prechádza do modrej,
ktorá sa nachádza na 120$^\circ$ stupňoch z kade prechádza cez červenú na 240$^\circ$ a keďže je to model kruhový, vracia sa do zelenej na 360$^\circ$.
Pomocou funkcie \emph{inRange} by nemal byť problém určiť rozhranie stupňov, ktoré sme schopný akceptovať ako hľadanú farbu pre hľadané naše dopravné značenia.
Ďalší kanál je \emph{Saturation}, ktorý predstavuje sýtosť farby. Táto sýtosť sa vyjadruje v percentách, kde 0\% predstavuje šedú a 100\% je plne sýta farba.\cite{hsl_hsv} 
V našom prípade je postacuje metóda \emph{threshold}. Posledný kanál \emph{Value} vyjadruje hodnotu jasu.
Keďže v praxi znamená znižovanie jasu pridávanie čiernej do základnej farby,
pre hľadanie červenej farby na dopravnom značení nie je potrebné s týmto kanálom pracovať, lebo červená farba použitá na dopravných značeniach je pomerne svetlá.
Pri hľadaní modrej je túto farbu potrebné trochu stmaviť a tak použijeme opäť funkciu \emph{threshold}.
\paragraph{}
Na koniec potrebujeme dostať len kontúry hľadanej farby. 
Najpr si budeme musieť spojiť jednotlivé kanály späť do jednej binárnej matice použitím metódy \emph{Canny}. 
Po tomto kroku by nám mali ostať len čierny obraz a biele škvrny predstavujúce červenú farbu v požadovanom rozsahu.
Z týchto bielych objektov, budeme potrebovať len okraje a tak použijeme metódu \emph{findContours}, ktorá sa postará o to, že dostaneme pole kontúr z celého obrazu.
S týmito kontúrami potom ďalej pracujeme a rozoznávame z nich hľadané útvary.
\subsubsection{Návrh algoritmu pre detekciu kruhov}
\paragraph{}
Pri detekcii dopravného značenia v tvare kruhu, je dôležité počítať s tým, že nehľadáme úplný kruh. Kruhové dopravné značenia sú vyrábané ako dokonalý kruh,
no pri ich rozpoznávaní si je potrené uvedomiť, že na objekt sa pozeráme z rôznych uhlov. Táto skutočnosť nám prináša do prolematiky dôležitý fakt,
že v skutočnosti to nie sú kruhy čo hľadáme, ale sú to elipsy. Celý algoritmus je možné vidieť na orázku č. \ref{hladanie_kruhov}
\begin{figure}[p]
\centering
\includegraphics[width=0.38\textwidth,natwidth=318,natheight=1164]{hladanie_kruhov.jpg}
\vspace{-20pt}
\caption{Algoritmus vyhľadávania kruhov v obraze}
\vspace{-10pt}
\label{hladanie_kruhov}
\end{figure}
\paragraph{}
Keďže v predchádzajúcej kapitole sme si navrhli riešenie, ktoré nám vracia len kontúry hľadanej farby, môžeme pokračovať od tohto bodu.
Ako prvé si spravíme cyklus, ktorým budeme prechádzať všetky naše vyhľadané kontúry farieb. Aby sme eliminovali počet prebytočných kontúr, 
je potrené spracovávať čo najrelevantnejšie výsledky. Tento úkon vykoná metóda \emph{contourArea}, vďaka ktorej budeme posielať na ďalšie spracovanie len kontúry väčšie ako 500 pixelov.
\paragraph{}
Vzhľadom na to, že výsledky, ktoré dostávame ešte nemôžeme nazvať elipsami, musíme si naše kontúry na elipsy upraviť.
Tento úkon vykonáva metóda \emph{fitEllipse}, ktorá upraví kostrbaté kontúry, ktoré sa aspoň trochu podobajú elipse, na matematicky presnú elipsu.
\paragraph{}
Keď už máme detekované elipsy, nastáva posledný krok, a tým krokom je, určiť si toleranciu elipsy dopravného značenia, ktorú vyhľadávam.
Táto tolerancia, je vlastne tolerancia nepresnosti, pri výpočte Ludolfovho čísla. 
Ďalším krokom je tak výpočet už spomínaného ludolfovho čísla a následné overenie jeho nepresnosti. 
Pokiaľ je výsledná hodnota vyhovujúca, nájdený objekt vyrežeme, a zasielame na rozpoznanie neurónovej sieti, ktorá zistí o akú značku sa presne jedná.
\paragraph{}
Výpočet Ludolfovho čísla:
\begin{align*}
          \pi = \frac{o}{d} \\
\end{align*}
Úprava výpočtu Ludolfovho čísla pre elipsu:
\begin{align*}
          p = \frac{o}{d} = \frac{o}{(\frac{1}{2} y) * ( \frac{1}{2} x)} \\
\end{align*}
Získanie tolerancie:
\begin{align*}
          \pi - p < 0.03 \\
\end{align*}
\paragraph{}
Pre určovanie tolerancie elipsy, je možné použiť ešte jednu metódu, a tou je overovanie podľa osí. 
Pokiaľ je x-ová os dvoj-násobne väčšia ako y-ová, ide už o elipsu, ktorú by sme ďalej len ťažko identifikovali. 
Takýto nežiaduci stav môže nastať, pokiaľ sa na značku pozeráme na dopravné značenie z príliž veľkého uhlu.
\paragraph{}
Dva nežiaduce stavy tvaru dopravného značenia:
\begin{align*}
		  \text{ 1.) }
          \frac{\frac{1}{2} x}{\frac{1}{2} y} > 2  \\
          \text{ 2.) }
          \frac{\frac{1}{2} y}{\frac{1}{2} x} > 2  \\
\end{align*}
\subsection{Návrh objektov - UML}
\paragraph{}
Algoritmy, ktoré boli navrhnuté, je potrebne správne zakomponovať do objektovo orientovaného modelu našej android aplikácie.
Je potrebné si správne navrhnúť ako budú jednotlivé algoritmy a funkcionality rozdelené do tried a taktiež aj to, ako budú triedy medzi sebou spolupracovať.
Celá štruktúra je najlepšie viditeľná na obrázku \ref{uml_objects_diagram}.
\begin{itemize}
  \item \textbf{SurfaceView} - Táto trieda je v jadre Android OS, ale je si potrebné vysvetliť jej probližnú funkcionalitu, keďže z nej priamo dedíme a upravujeme ju v ďalších triedach našej aplikácie.
  Poskytuje špecializovanú kresliacu plochu. Podoba tejto plochy sa dá meniť, dá sa jednoducho meniť napríklad veľkosť alebo samotné umiestnenie. \cite{android_dev}
  \item \textbf{Activity} - Táto trieda je taktiež priamo v jadre Android OS, ale keďže z nej taktiež dedíme, vasvetlíme si jej hlavný princíp.
  Táto trieda má na starosti komunikáciu s užívateľom. Všetko čo užívateľ s aplikáciou spraví, napríklad čo sa stane s aplikáciou pokiaľ užívateľ pozastaví priebeh vykonávania, alebo čo sa bude diať po výbere jednotlivých položiek v menu. \cite{android_dev}
  \item \textbf{BaseClass} - Táto trieda dedí z triedy \emph{SurfaceView} a nastavuje našu plochu. Keďže na našej aplikácii máme v pláne mať na ploche hlavne pohľad z kamery, v tejto triede sa staráme o všetky správne nastavenia kamery a zobrazenia pre hlavnú plochu aplikácie.
  \item \textbf{ActivityView} - Trieda dedí z triedy \emph{Activity}. V tejto aplikácii sa nastavujú všetky akcie ktoré v našej android aplikácii môžu nastať a taktiež aj naše hlavné menu z ktorého si užívateľ vyberá akcie.
  \item \textbf{Detection} - Je to hlavná trieda zodpovedná za rozpoznanie jednotlivých objektov, nastavujeme v nej taktiež rôzne parametre, ktoré sa použijú neskôr v triedach, ktoré z našej triedy \emph{Detection} dedia.
  \item \textbf{Color} - Trieda \emph{Color} bude dediť z \emph{Detection}. Jej hlavná úloha je rozpoznávať jednotlivé farby.
  \item \textbf{Shape} - Trieda \emph{Shape} bude dediť z \emph{Detection}. Jej hlavná úloha je rozpoznávať tvary z obrazu.
  \item \textbf{Traffic} - Trieda \emph{Traffic} bude taktiež dediť z triedy \emph{Detection}. Jej hlavná úloha je rozpoznávať dopravné značenia. Využíva na to spoluprácu tried \emph{Shape} a \emph{Color}.
\end{itemize}
\begin{figure}[p]
\centering
\includegraphics[width=1\textwidth,natwidth=800,natheight=1000]{uml_objects.jpg}
\vspace{-10pt}
\caption{Návrh objektov Android aplikácie}
\vspace{-10pt}
\label{uml_objects_diagram}
\end{figure}
\subsection{Návrh užívteľského prostredia}
\paragraph{}
Prostredie aplikácie bude veľmi jednoduché. Celé rozhranie, bude pozostávať z dvoch častí. Jedna časť bude naša plocha, tam sa budú graficky znázorňovať nájdené objekty, v našom prípade dorpavné značenia, ale taktiež aj rôzne filtre, ktoré budeme chcieť prezentovať ako ukážku.
Druhá časť bude menu, v ktorom si užívateľ bude vyberať z možností ktoré tam budú a následne sa budú vykonávať rôzne. V menu bude napríklad prepínanie rôznych filtrov alebo spôsobov vyhľadávania dopravných značení.
%%TODO fotografie alebo navrh
\section{Implementácia}
\paragraph{}
V tejto sekcii sa budem snažiť popísať implementáciu a správne nastavenie technológií, ktoré sa v aplikácii využijú.
\subsection{Android implementácia}
\paragraph{}
Pri aplikácii pre android je potrebné upraviť v triedach aj samotnú spoluprácu s mobilom a jadrom Androidu. Rozdelil som túto spoluprácu do dvoch logických celkov. Rozdelil som to na triedu \emph{BaseClass} a triedu \emph{ActivityView}.
\subsubsection{BaseClass}
\paragraph{}
V tejto triede nastavujeme plochu našej android aplikácie.
Trieda obsahuje mnoho metód ktoré sa venujú napríklad otváraniu kamery a nastaveniam kamery. Metóda zaoberajúca sa otvorením kamery je \emph{openCamera}.
V tejto metóde sa zisťuje či sa kamera dá otvoriť, pokiaľ áno, tak ju samozrejme otvoríme a pokiaľ nie, tak ukončíme aplikáciu a dáme vedieť užívateľovi čo sa stalo.
\lstset{language=Java,caption={Spustenie kamery},label=camera_code}
\begin{lstlisting}
	public boolean openCamera() {
        Log.i(TAG, "openCamera");
        releaseCamera();
        mCamera = Camera.open();
        if(mCamera == null) {
        	Log.e(TAG, "Nemozem otvorit kameru");
        	return false;
        }

        mCamera.setPreviewCallbackWithBuffer(new PreviewCallback() {
            public void onPreviewFrame(byte[] data, Camera camera) {
                synchronized (BaseClass.this) {
                    System.arraycopy(data, 0, mFrame, 0, data.length);
                    BaseClass.this.notify(); 
                }
                camera.addCallbackBuffer(mBuffer);
            }
        });
        return true;
    }
\end{lstlisting}
Ďalšia metóda \emph{releaseCamera} uvoľní, alebo reštartne kameru. V metóde \emph{setupCamera} nastavíme potrebné nastavenia kamery a obrazu v ktorom sa bude zobrazovať.
My si kameru nastavíme na celú plochu aplikácie a taktiež jej nastavíme automatické ostrenie.
\subsubsection{ActivityView}
\paragraph{}
Trieda \emph{ActivityView} rieši všetky aktivity vykonávané v aplikácii. \emph{onPause} metóda zastaví kameru a reštartne ju. Metóda \emph{onResume} nám rieši situáciu, keď sa k aplikácii vrátime.
Spúšta znovu kameru a overuje či je možné ďalej pokračovať. Pri negatívnom stave upozorní užívateľa o ukončení aplikácie. Pri metóde \emph{onCreate} načítavame OpenCV a zistujeme, aktuálnu verziu OpenCV v zariadení.
Pokiaľ je zastaralá, alebo vôbec neexistuje, vyzveme užívateľa aby si ju dodatočne stiahol. Samozrejme mu pomôžeme s nájdením správnej verzie a pokiaľ má záujem ďalej pokračovať, dovedieme ho ku správnej verzii my.
Samozrejme pokiaľ aj tu nastane nejaká chyba, je potrebné aplikáciu ukončiť a upozorniť na to užívateľa. V metóde \emph{onCreateOptionsMenu} nastavíme položky v menu a texty ktoré sa majú vypisovať. 
Samotná aktivita po kliku na menu sa rieši v metóde \emph{onOptionsItemSelected}.
\subsubsection{ActivityFunctionality}
\paragraph{}
V tejto triede sa rieši logika prepájania interakcie s jadrom rospoznávania. Taktiež sa tu rieši to, čo sa stane počas načítavania samotnej aplikácie.
Je dobŕe si čo najviac vecí načítať práve v tejto fáze, aby sme sa odbremenili od záťaže pri behu samotnej aplikácie. Práve toto sa rieši v metóde \emph{onPreviewStarted}, kde si načítame všetky rozmery obrazu pre rôzne filtre.
To čo sa stane pokiaľ aplikácia zastane sa rieši v metóde \emph{onPreviewStopped}. Tu je potrebné všetky premenné, polia a zoznamy uvoľniť. Veľmi dôležitá robota sa vykonáva v metóde \emph{processFrame}.
Tu komunikujeme s menu a rozdelujeme čo sa stane po zvolení jednotlivých položiek. Technika prepínania bola zvolená pomocou funkcie \emph{switch}, ktorá nás rozdeľuje do rôznych stavov. Pri detekovaní dopravných značení, je to práve tu, kde spúštame vyhľadávanie a následne vykesľujeme na plochu štvorce s nájdenými objektami.
\lstset{language=Java,caption={Výber z menu - hľadanie dopravných značiek},label=menu_search_code}
\begin{lstlisting}
	Imgproc.cvtColor(mYuv, mRgba, Imgproc.COLOR_YUV420sp2RGB, 4);
	//nastavene dat
	traffic.setData(mRgba);
	//najdene cervenych objektov
	traffic.detectRedCircleSign();
	//vycistenie zoznamu so stvorcami
	boxList.clear();
	//naplnenie zoznamu so stvorcami
	boxList = traffic.getBoxList();
	//vycistenie zoznamu so znackami
	signList.clear();
	//naplnenie zoznamu so znackami
	signList = traffic.getSignList();
	//kreslenie stvorcov
	for(int i = 0; i < boxList.size(); i++){
		Rect r=boxList.get(i);
		Core.rectangle(mRgba, r.tl(), r.br(), new Scalar(0, 255, 0, 255), 3);
	}
\end{lstlisting}
\subsection{Rozpoznávacie jadro}
\paragraph{}
Rozpoznávacie jadro je rozdelené do logických celkov do tried, podľa druhu objektov ktoré rozpoznávajú.
\subsubsection{Detection}
\paragraph{}
Je to hlavná trieda z ktorej všetky ďalšie triedy ktoré rozpoznávajú konkrétne objekty dedia.
V tejto triede sa nastavujú základné informácie potrebné pre rozpoznávanie.
Obsahuje dva konštruktory, ktoré sa spúštajú na základe parametrov a pri každom spustení reštartuje všetky objavené dopravné značenia.
Keďže aplikácia potrebuje rôzne vstupy, je potrebné nastaviť pre jednotlivé ukážky rôzne vstupné premenné obsahujúce vstupný obraz.
\subsubsection{Color}
\paragraph{}
Trieda \emph{Color} je zodpovedná za rozpoznávanie farieb na dopravných značeniach. Obsahuje metódy, ktoré sú pomenované podľa farby ktorú vie daná metóda rozpoznávať.
Už ako z názvu vyplíva, metóda \emph{Red} bude rozpoznávať červenú farbu v obraze. V metóde si najprv nastavíme potrebné premenné s ktorými budeme neskôr pracovať.
Ako prvé potrebujeme previesť obraz z bitmapy do binárnej matice typu \emph{Mat}, pomocou funkcie \emph{bitmapToMat}.
Ďaľej sa pokúsime rozmazať obraz, pomocou \emph{GaussianBlur}. Táto funkcia nám vracia formát obrazu ako RGBA, no pre ďalšiu prácu budeme potrebovať RGB a taktiež HSV.
Toto docielime použitím \emph{cvtColor}. Funkcia \emph{split} nám docieli to, že náš obraz rozdelí na 3 kanály, ktoré filter HSV obsahuje a ktoré potrebujeme pre ďalšie filtrovanie obrazu.
H kanál budeme filtrovať pomocou funkcie \emph{inRange}, keďže vstup môže byť aj vektor.
\lstset{language=Java,caption={Konverzia obrazu cez rôzne filtre},label=filter_h_chanel_code}
\begin{lstlisting}
	//konverzia vstupneho obrazu
	Utils.bitmapToMat(image, mRGBA);
	//rozmazanie obrazu
	Imgproc.GaussianBlur(mRGBA,mRGBA,new Size(5, 5),1.5,1.5);
	//prevedenie RGBA na RGB
	Imgproc.cvtColor(mRGBA,mRGB,Imgproc.COLOR_RGBA2RGB);
	//prevedenie RGB na HSV
	Imgproc.cvtColor(mRGB,mTemp,Imgproc.COLOR_RGB2HSV);
	//rozdelenie
	Core.split(mTemp,lHSV);
	//filtrovanie kanalu H
	mTemp=new Mat();
	Core.inRange(lHSV.get(0), new Scalar(90), new Scalar(130), mTemp);
	lHSV.set(0, mTemp);
\end{lstlisting}
Pre ďalšie dva kanály bude stačiť použiť funkciu \emph{threshold}.
Funkcia \emph{Canny} nám prekonvertuje obraz na 8-bitový čierny obraz, na ktorom sa nachádza mnoho bielych objektov. Tieto biele objekty predstavujú červenú farbu. 
Na záver je potrebné získať všetky červené objekty len ako kontúry. S týmto problémom nám pomôže funkcia \emph{findContours}, ktorá získa z nájdených objektov červenej farby len ich kontúry.
Metóda na záver vracia zoznam všetkých nájdených kontúr, ktoré považujeme za okraje za červených objektov.
Pri metóde \emph{Blue} a taktiež v prípade vyhľadávania iných farieb, by stačilo zmeniť parametre fo funkciách, ktoré spracovávajú jednotlivé kanály HSV filtra.
\subsubsection{Shape}
\paragraph{}
V tejto triede sa venujeme problematike rozpoznávania tvarov. Tvary nerozpoznávame priamo z obrazu, ale zo zoznamu kontúr ktoré sme pri rozpoznaní farby už dostali.
Rovnako ako v predchádzajúcej triede, sme pomenovali jednotlivé metódy podľa objektu aký rozpoznáva. Vznikli tak metódy \emph{Circle} a \emph{Triangle}.
Síce spracovávame už existujúce kontúry budeme potrebovať aj samotný snímaný obraz a tak je potrebné si tento obraz opäť previesť na binárny obraz typu \emph{Mat}, pomocou funkcie \emph{bitmapToMat}.
Nasleduje cyklus s podmienkou na konci, kedy zisťujeme, či už sme na konci, alebo, či nie sme len v dieťati nejakej rodičovskej kontúry. Vytvoríme si buffer, do ktorého načítame dodatočné informácie kontúr, ktoré sa nachádzajú v premennej \emph{hierarchy}.
Načítame si potrebnú kontúru s ktorou ideme pracovať. Ako prvé, ju overíme, či je veľkosť kontúry dostatočne veľká, aby malo zmysel sa s ňou zaoberať. Tu sme sa rozhodli, pracovať s kontúrami, ktoré su väčšie ako 500 pixelov.
Veľkosť kontúry sa nám podarí získať pomocou funkcie \emph{contourArea}.
\lstset{language=Java,caption={Načítanie a overenie veľkosti kontúry},label=contourArea_code}
\begin{lstlisting}
	int buff[] = new int[4];
	//i sme dostali so vstupu
	hierarchy.get(0, i, buff);
	Mat contour = contours.get(i);
	int id = i;
	i = buff[0];
	if(Imgproc.contourArea(contour) > 500){
\end{lstlisting}
Po tento bod je každá metóda v triede \emph{Shape} rovnaká, od tadeto sa mení spôsob rozpoznania jednotlivých tvarov. 
Pre rozpoznanie kruhov, je našou úlohou nastaviť si najmenšiu možnú elipsu pre danú kontúru.
Nie je to však tak jednoduchá úloha. Ako prvé je potrebné konvertovať naše kontúry na maticu typu \emph{MatOfPoint2f}.
Toto prevedieme pomocou cyklu, v ktorom iba rozširujeme počet bitov a následne konvertujeme pomocou \emph{toArray}.
Hneď ako sa nám konverzia podarí, môžeme použiť našu funkciu \emph{fitEllipse}, ktorá nám vykreslí najmenšiu možnú elipsu.
\lstset{language=Java,caption={Konverzia do MatOfPoint2f a použitie fitEllipse},label=fitEllipse_code}
\begin{lstlisting}
	//pocet kontur
	int num = (int)contour.total();
	//vytvorime si pole o dvojnasobnej velkosti samotnej kontury
	int temp[] = new int[num * 2];
	//nacitame si konturu do docasnej premennej
	contour.get(0, 0, temp);
	//konvertujeme  List<Point> do MatOfPoint2f pre pouzitie fitEllipse
	for(int j = 0; j < num * 2; j = j + 2){
		points.add(new Point(temp[j], temp[j+1]));
	}
	MatOfPoint2f specialPointMtx = new MatOfPoint2f(points.toArray(new Point[0])); 
	//do premennej bound ukladame dokonalu - najmensiu moznu elipsu
	RotatedRect bound = Imgproc.fitEllipse(specialPointMtx);
\end{lstlisting}
Je potrebné si vypočítať a overiť toleranciu k hodnote PI. Výpočet sa spraví podľa vzorca opísaného v časti 3.1.2, a následne sa overí tolerancia.
\lstset{language=Java,caption={Vypočet PI},label=pi_code}
\begin{lstlisting}
	//vypocita sa hodnota pi
	double pi = Imgproc.contourArea(contour) / ((bound.size.height / 2) * (bound.size.width / 2));
\end{lstlisting}
Spraví sa ešte jedno overenie pre elipsu a následne sa vyreže obraz okolo značky a ukladá sa do zoznamu \emph{boxList} s ktorým neskôr môžeme ďalej pracovať.
\lstset{language=Java,caption={Overenie oválnosti našej elipsy},label=axis_code}
\begin{lstlisting}
	double longAxis;
	double shortAxis;
	//ziska dve osy elipsy
	if (bound.size.height < bound.size.width){
		shortAxis = bound.size.height / 2;
		longAxis = bound.size.width / 2;
	} else {
		shortAxis = bound.size.width / 2;
		longAxis = bound.size.height / 2;
	}
	//this could stop the searching when is elipse too oval 
	if ((longAxis / shortAxis) < 2.0){
		signList.add(roi);
		boxList.add(box);
	}
\end{lstlisting}
\subsubsection{Traffic}
V triede sa nachádzajú jednotlivé metódy rozpoznávania spojené po logických celkoch. Napríklad rozpoznanie kruhových červených značení, alebo všetkých značení.
V takej metóde \emph{detectRCS} sa použijú len metódy z tried \emph{Color} a \emph{Shape}.
\lstset{language=Java,caption={Detekcia červených okrúhlich dopravných značení},label=traffic_code}
\begin{lstlisting}
	//vypocita sa hodnota pi
	List<MatOfPoint> contours = Color.Red(i);
	if(contours.size()>0){
		Shape.Circle(contours, 0);
	}
\end{lstlisting}
\section{Výsledky aplikácie}
\subsection{Detekcia kruhových značiek}
\subsubsection{Značky modrej farby}
\subsubsection{Značky červenej farby}

\clearpage
\section*{Záver}
\clearpage

\bibliography{bach}
\bibliographystyle{plain}

\end{document}
